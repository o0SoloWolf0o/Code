สปอย 1
Facebook Mini
เราเก็บความสัมพันธ์ของเพื่อนๆ ไว้ใน 
Adjacency Metrix หรือ List
Facebook อยากให้คนเชื่อมต่อกันเยอะๆ
เลยออกแบบระบบสำหรับแนะนำเพื่อนขึ้นมา
ระบบแนะนำเพื่อนก็ไม่ยาก
เพียงหาว่าคนสองคนที่มีเพื่อนเหมือนกันมากที่สุด
แล้วก็ทำการแนะนำเพื่อนที่มีเพื่อนร่วมกัน
พร้อมกับวิเคราะห์ complexity ของโปรแกรม
คะแนนเต็มคือตอบถูก
คะแนนที่เกินคือ complexity ที่ลดลง


สปอยล์ข้อสอบ ไม่ได้ออกทุกข้อ

1.จงวิเคราะห์กรณีที่ดีที่สุดของ insertion sort พร้อมอธิบายว่าเมื่อไหร่ที่เราควรใช้ insertion sort
กรณีที่ดีที่สุดของ insertion sort คือข้อมูลทั้งหมดถูกจัดเรียงข้อมูลตามลำดับเรียงกันแล้ว และเราต้องการจัดเรียงข้อมูลใหม่เข้าไปในข้อมูลที่ถูกจัดเรียงแล้ว ในกรณีนี้ insertion sort จะทำงานได้ดีที่สุด เพราะว่าเราจะไม่ต้องทำการเปลี่ยนแปลงข้อมูลใดๆ ในข้อมูลที่ถูกจัดเรียงแล้ว และเราจะเพิ่มข้อมูลใหม่เข้าไปในข้อมูลที่ถูกจัดเรียงแล้วได้เร็วที่สุด โดยมี Time complexity เป็น O(n) และ Space complexity เป็น O(1) เราควรใช้ insertion sort ตอนที่ข้อมูลมีการเพิ่มเข้ามาใหม่เรี่อยๆ ก่อนนำข้อมูลเพื่อนำไปวิเคราะห์ต่อไป

2.จงวิเคราะห์กรณีที่เลวร้ายที่สุดของ insertion sort พร้อมอธิบายว่าเมื่อไหร่ที่เราไม่ควรใช้ insertion sort
กรณีที่เลวร้ายที่สุดของ insertion sort คือข้อมูลทั้งหมดไม่ถูกจัดเรียงข้อมูลตามลำดับเรียงกันแล้ว ในกรณีนี้ insertion sort จะทำงานได้เลวร้ายที่สุด เพราะว่าเราจะต้องทำการเปลี่ยนแปลงข้อมูลในข้อมูลที่ถูกจัดเรียงแล้ว และเราจะเพิ่มข้อมูลใหม่เข้าไปในข้อมูลที่ถูกจัดเรียงแล้วได้ช้าที่สุด โดยมี Time complexity เป็น O(n^2) และ Space complexity เป็น O(1) เราไม่ควรใช้ insertion sort ตอนที่ข้อมูลที่ไม่เรียงลำดับกันเลย และข้อมูลที่เรียงลำดับแล้วมีขนาดใหญ่เกินไป

3.จงวิเคราะห์กรณีที่ดีที่สุดของ quick sort พร้อมอธิบายว่าเมื่อไหร่ที่เราควรใช้ quick sort
กรณีที่ดีที่สุดของ quick sort คือข้อมูลที่ถูกจัดเรียงแล้ว ในกรณีนี้ quick sort จะทำงานได้ดีที่สุด เพราะว่าเราจะไม่ต้องทำการเปลี่ยนแปลงข้อมูลในข้อมูลที่ถูกจัดเรียงแล้ว และเราจะเพิ่มข้อมูลใหม่เข้าไปในข้อมูลที่ถูกจัดเรียงแล้วได้เร็วที่สุด โดยมี Time complexity เป็น O(nlogn) และ Space complexity เป็น O(logn) เราควรใช้ quick sort ตอนที่ข้อมูลที่ไม่เรียงลำดับกันเลย และข้อมูลที่เรียงลำดับแล้วมีขนาดใหญ่เกินไป

4.จงวิเคราะห์กรณีที่เลวร้ายที่สุดของ quick sort พร้อมอธิบายว่าเมื่อไหร่ที่เราไม่ควรใช้ quick sort (ไม่นับ LVQuickSort)
กรณีที่เลวร้ายที่สุดของ quick sort คือข้อมูลที่ถูกจัดเรียงแล้ว และข้อมูลที่เรียงลำดับแล้วมีขนาดเล็ก โดยมี Time complexity เป็น O(n^2) และ Space complexity เป็น O(logn) เราไม่ควรใช้ quick sort ตอนที่ข้อมูลที่เรียงลำดับแล้วมีขนาดเล็กเกินไป และข้อมูลที่ไม่เรียงลำดับกันเลยเล็กเกินไป

5.จงวิเคราะห์ radix sort หรือ bucket sort พร้อมอธิบายว่าเมื่อไหร่ที่เราควรใช้ radix sort หรือ bucket sort และเมื่อไหร่ไม่ควรใช้
กรณีที่ดีที่สุดของ radix sort หรือ bucket sort คือข้อมูลที่เรียงลำดับแล้วมีขนาดใหญ่ และข้อมูลที่ไม่เรียงลำดับกันเลยเล็กเกินไป และข้อมูลที่เรียงลำดับแล้วมีขนาดเล็ก โดยมี Time complexity เป็น O(n) และ Space complexity เป็น O(n) เราควรใช้ radix sort ตอนที่ข้อมูลที่เรียงลำดับแล้วมีขนาดใหญ่ และข้อมูลที่ไม่เรียงลำดับกันเลยเล็กเกินไป

กรณีที่เลวร้ายที่สุดของ radix sort หรือ bucket sort คือข้อมูลที่เรียงลำดับแล้วมีขนาดเล็ก และข้อมูลที่ไม่เรียงลำดับกันเลยมีขนาดใหญ่ โดยมี Time complexity เป็น O(n^2) และ Space complexity เป็น O(n) เราไม่ควรใช้ radix sort ตอนที่ข้อมูลที่เรียงลำดับแล้วมีขนาดเล็ก และข้อมูลที่ไม่เรียงลำดับกันเลยมีขนาดใหญ่

6.จงวิเคราะห์เปรียบเทียบกันระหว่าง Dijkstra ที่ใช้ Heap และ ไม่ได้ใช้ Heap
กรณี Dijkstra ที่ใช้ Heap คือมี Time complexity เป็น O((V+E)logV) และ Space complexity เป็น O(V) โดยเราจะใช้ Heap ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่ และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก

กรณี Dijkstra ที่ไม่ได้ใช้ Heap คือมี Time complexity เป็น O(V^2) และ Space complexity เป็น O(V) โดยเราจะใช้ Dijkstra ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่

7.จงวิเคราะห์เปรียบเทียบกันระหว่าง Huffman Coding ที่ใช้ Heap และไม่ได้ใช้ Heap
กรณี Huffman Coding ที่ใช้ Heap คือมี Time complexity เป็น O(nlogn) และ Space complexity เป็น O(n) โดยเราจะใช้ Huffman Coding ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่ และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก

กรณี Huffman Coding ที่ไม่ได้ใช้ Heap คือมี Time complexity เป็น O(n^2) และ Space complexity เป็น O(n) โดยเราจะใช้ Huffman Coding ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่

8.จงวิเคราะห์เปรียบเทียบกันระหว่าง Kruskal ที่ใช้ Heap และไม่ได้ใช้ Heap
กรณี Kruskal ที่ใช้ Heap คือมี Time complexity เป็น O(ElogE) และ Space complexity เป็น O(E) โดยเราจะใช้ Kruskal ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่ และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก

กรณี Kruskal ที่ไม่ได้ใช้ Heap คือมี Time complexity เป็น O(ElogV) และ Space complexity เป็น O(E) โดยเราจะใช้ Kruskal ตอนที่ข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดเล็ก และข้อมูลที่เราจะหาค่าน้อยที่สุดมีขนาดใหญ่

9.จงวิเคราะห์ว่าการใช้ Disjoint Set หรือว่า Uptree ใน Kruskal สามารถทำ path compression ได้หรือไม่ ถ้าได้ประสิทธิภาพจะดีขึ้นเท่าไหร่
Disjoint Set หรือว่า Uptree ใน Kruskal สามารถทำ path compression ได้ และประสิทธิภาพจะดีขึ้นเท่ากับ O(ElogV)

10.จงวิเคราะห์ว่าการใช้ Disjoint Set หรือว่า Uptree ใน Dijkstra สามารถทำ path compression ได้หรือไม่ ถ้าได้ประสิทธิภาพจะดีขึ้นเท่าไหร่
Disjoint Set หรือว่า Uptree ใน Dijkstra สามารถทำ path compression ได้ และประสิทธิภาพจะดีขึ้นเท่ากับ O(ElogV)

11.จงวิเคราะห์ข้อเสียของ Binary search tree พร้อมวิเคราะห์ว่า AVL tree ใช้แก้ข้อเสียนั้นได้อย่างไร และเราต้องแลกอะไรไปเพื่อแก้ข้อเสียเหล่านั้นได้
ข้อเสียของ Binary search tree คือมีการเกิดการเลื่อนข้อมูลที่ไม่จำเป็น และเราต้องแลกอะไรไปเพื่อแก้ข้อเสียเหล่านั้นได้คือการใช้ AVL tree จะทำให้มีการเกิดการเลื่อนข้อมูลที่ไม่จำเป็นน้อยลงโดยแลกกับการใช้พื้นที่เพิ่มขึ้น

12.จงเปรียบเทียบข้อดีข้อเสียของการใช้ Open Addressing, Linked List, Bucket และ Rehashing เมื่อ hash key เกิดการชนกันในแง่ของเวลา พื้นที่จัดเก็บ และ การเพิ่มลบข้อมูลจะช้ากว่า
ข้อดีของ Open Addressing คือ การเพิ่มลบข้อมูลจะเร็วกว่า Linked List และ Bucket และข้อเสียคือ การเพิ่มลบข้อมูลจะช้ากว่า Linked List และ Bucket และ
ข้อดีของ Linked List คือ การเพิ่มลบข้อมูลจะเร็วกว่า Open Addressing และ Bucket และข้อเสียคือ การเพิ่มลบข้อมูลจะช้ากว่า Open Addressing และ Bucket และ
ข้อดีของ Bucket คือ การเพิ่มลบข้อมูลจะเร็วกว่า Open Addressing และ Linked List และข้อเสียคือ การเพิ่มลบข้อมูลจะช้ากว่า Open Addressing และ Linked List และ
ข้อดีของ Rehashing คือ การเพิ่มลบข้อมูลจะเร็วกว่า Open Addressing และ Linked List และ Bucket และข้อเสียคือ การเพิ่มลบข้อมูลจะช้ากว่า Open Addressing และ Linked List และ Bucket

สปอยล์ 3
มีกราฟมาให้จงแสดงขั้นตอนเพื่อหาคำตอบของ spanning tree ในโจทย์จะระบุว่าให้ใช้วิธีไหน พร้อมแสดงข้อมูลที่อยู่ในโครงสร้างข้อมูล (แสดงวิธีทำ)
ขั้นตอนการหา spanning tree 